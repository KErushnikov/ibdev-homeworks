# Dockerfile

В этом руководстве вы изучите, как упаковать приложение [без зависимостей](assets/app.bin) в Docker-образ и запустить контейнер.

Для корректного выполнения задания, необходимо скачать директорию assets, в которой содержатся файлы для выполнения. В данном случае - исполняемый файл программы которая будет запущена внутри контейнера. 

Часто приложение, не использующее внешних зависимостей (статически слинкованное), не требует контейнеризации, так как вы получаете исполняемый файл, который можно развернуть в целевой операционной системе.

Самое важное, что контейнеризация унифицирует процесс эксплуатации приложений на разных языках. То есть системным администраторам или другим сотрудникам, отвечающим за эксплуатацию приложений, в том числе за развёртывание и мониторинг, будет удобнее, если все приложения будут поставляться в унифицированном формате, как Docker-образы. Именно поэтому мы рассматриваем упаковку приложений в образ.

`Dockerfile` — специальный текстовый файл, описывающий процесс создания образов. Он должен находиться в том же каталоге, что и файл `app.bin`.

## Layered system

Почти каждая инструкция, которую мы будем рассматривать, создаёт в рамках образа определённый слой (layer):

```
+------------------------+
|        layer N         |
+------------------------+
|        layer N - 1     |
+------------------------+
|        ...             |
+------------------------+
|        layer 1         |
+------------------------+
```

Вы можете представлять каждый слой в виде снапшота (слепка) файловой системы. Эти уровни накладываются друг на друга снизу вверх, формируя итоговое состояние файловой системы.

Это позволяет:
1. Переиспользовать слои между несколькими образами.
2. Экономить время сборки. Мы переделываем только необходимые слои и все вышестоящие.

Сами слои не изменяются.

Давайте посмотрим на практике, как выглядит работа со слоями.

## `FROM`

Инструкция `FROM` позволяет выбрать базовый образ, с которого вы начнёте создание собственного.

Вы начнёте с «нуля» и возьмёте специальный "образ" [`scratch`](https://hub.docker.com/_/scratch). Он, кстати, не создаёт layer'a — это «пустая» ФС, в которой нет никаких файлов. На самом деле, scratch это зарезервированный образ, который указывает на то, что родительского образа нет, а используется ядро контейнеризации без дополнительных библиотек и программ. Скачивать образ в данном случае не надо. Если используете базовый образ, например ubuntu, alpine или debian, то сначала образ надо скачать командой `docker pull <название образа:тег>`

```dockerfile
FROM scratch
```

Примечание*. Вы можете использовать [любой образ](https://hub.docker.com) в качестве базового. Пока вы умеете работать только с общедоступными с Docker Hub, но позже научитесь и с другими.

## `COPY`

Инструкция `COPY` даёт вам возможность добавить из локальной файловой системы, с вашего компьютера, файлы и каталоги в образ.
Формат команды: `COPY src dst`, где `src` — это исходный файл или каталог, а `dst` — это целевой файл или каталог.

```dockerfile
FROM scratch

COPY app.bin /
```

Примечание*. Сначала убедитесь, что у файла есть права на исполнение (`chmod +x app.bin`). Помните, что команды выполняются из директории где находится файл `Dockerile`, поэтому `app.bin` должен находится в той же директории что и сам `Dockerfile`. Если файл находится в дочерней папке, то надо указывать путь с учетом директории -   `COPY assets/app.bin / `

Обратите внимание: в качестве `src` вы написали имя файла, а в качестве `dst` — имя каталога, т. к. заканчивается на `/`. В итоге ваш файл будет скопирован в каталог `/`.

Теперь можете попробовать собрать ваш первый образ:

```shell script
docker build .
```

Лог:

```
Sending build context to Docker daemon  2.193MB
Step 1/3 : FROM scratch
 ---> 
Step 2/3 : COPY app.bin /
 ---> 66535cd5be8d
Step 3/3 : CMD /app.bin
 ---> Running in 1ed1c71ff674
Removing intermediate container 1ed1c71ff674
 ---> b2c25c8fe693
Successfully built b2c25c8fe693
```

Примечание*. «Цифры», на самом деле это первые символы хеша слоёв, могут отличаться.

Теперь если выполнить команду `docker image ls`, вы увидите ваш образ в списке:

```
REPOSITORY     TAG        IMAGE ID          CREATED             SIZE
<none>         <none>     b2c25c8fe693      About a minute ago  2.19MB
```

При попытке повторной сборки (`docker build .`) вы заметите, что ничего заново не соберётся, а Docker просто переиспользует полученные слои (`---> Using cache`):

```
Sending build context to Docker daemon  2.193MB
Step 1/3 : FROM scratch
 ---> 
Step 2/3 : COPY app.bin /
 ---> Using cache
 ---> 66535cd5be8d
Step 3/3 : CMD /app.bin
 ---> Using cache
 ---> b2c25c8fe693
Successfully built b2c25c8fe693
```

## Label

Как вы видели, не особо удобно распознавать образы по `id`:

```
REPOSITORY     TAG        IMAGE ID          CREATED             SIZE
<none>         <none>     b2c25c8fe693      About a minute ago  2.19MB
```

Поэтому давайте присвоим вашему образу тег:

```shell script
docker build -t ibdevapp .
```

Лог:
```
Sending build context to Docker daemon  2.193MB
Step 1/3 : FROM scratch
 ---> 
Step 2/3 : COPY app.bin /
 ---> Using cache
 ---> 66535cd5be8d
Step 3/3 : CMD /app.bin
 ---> Using cache
 ---> b2c25c8fe693
Successfully built b2c25c8fe693
Successfully tagged ibdevapp:latest
```

```
REPOSITORY     TAG        IMAGE ID          CREATED             SIZE
ibdevapp       latest     b2c25c8fe693      4 minutes ago       2.19MB
```

## `CMD`

Инструкция `CMD` используется для указания исполняемого файла, который будет запускаться при старте контейнера, то есть когда вы делаете `docker container run <имя_образа>`:

```dockerfile
FROM scratch

COPY app.bin /

CMD ["/app.bin"]
```

## Итоговый `Dockerfile`

```dockerfile
FROM scratch

COPY app.bin /

CMD ["/app.bin"]
```

Подробная информация о командах Docker есть в [официальной документации](https://docs.docker.com/engine/reference/builder/).